## 云函数内使用JQL
## Using JQL in cloud functions

> 新增于HBuilderX 3.3.1版本
> Added in HBuilderX version 3.3.1

对于不适合在前端暴露的数据库操作，过去只能在云函数中使用传统MongoDB语法。此次更新让云函数也可以使用 JQL 来操作数据库。
For database operations that are not suitable for exposure on the front end, traditional MongoDB syntax can only be used in cloud functions in the past. This update makes it possible for cloud functions to also use JQL to operate on the database.

相比于传统 MongoDB语法，JQL 为云函数带来如下价值：
Compared with the traditional MongoDB syntax, JQL brings the following values to cloud functions:

1. JQL 优化了联表查询、Tree查询、虚拟表查询等，比 MongoDB语法更易用
1. JQL optimizes join table query, tree query, virtual table query, etc., which is easier to use than MongoDB syntax
2. 支持 DB Schema，包括各种值域约束和权限校验。无需再开发接口的权限和数据合法性验证代码
2. Support DB Schema, including various range constraints and authority verification. No need to develop interface permissions and data validity verification code

本文主要讲解云函数中如何使用 JQL 。详细的 JQL 语法另见文档：[JQL数据库操作](uniCloud/jql.md)
This article mainly explains how to use JQL in cloud functions. For detailed JQL syntax, see the document: [JQL database operations](uniCloud/jql.md)

## 为云函数添加jql扩展库
## Add jql extension library for cloud function

JQL 操作的引擎代码体积不小，考虑到有的云函数并不操作数据库或不使用JQL，所以相关功能被剥离在`uni-cloud-jql`扩展库中。
The engine code of JQL operation is not small. Considering that some cloud functions do not operate the database or use JQL, the related functions are stripped in the `uni-cloud-jql` extension library.

HBuilderX 3.4起，新建云函数/云对象，**默认加载**`uni-cloud-jql`扩展库。对于老云函数，也可以对云函数点右键 -> 管理公共模块或扩展库依赖 -> 选择`uni-cloud-jql`
Starting from HBuilderX 3.4, when creating a new cloud function/cloud object, the `uni-cloud-jql` extension library is loaded by default. For old cloud functions, you can also right-click the cloud function -> manage public modules or extended library dependencies -> select `uni-cloud-jql`

HBuilderX 3.4以前的开发者，需要在云函数的package.json内手动添加扩展库。（如果云函数目录下没有package.json，可以通过在云函数目录下执行`npm init -y`来生成）
Developers before HBuilderX 3.4 need to manually add the extension library in the package.json of the cloud function. (If there is no package.json in the cloud function directory, it can be generated by executing `npm init -y` in the cloud function directory)

下面是一个开启了jql扩展库的云函数的package.json示例，**注意不可有注释，以下文件内容中的注释仅为说明，如果拷贝此文件，切记去除注释**
The following is an example of package.json for a cloud function with the jql extension library enabled. **Note that there should be no comments. The comments in the following file content are for illustration only. If you copy this file, remember to remove the comments**

```js
{
	"name": "jql-test",
	"version": "1.0.0",
	"description": "",
	"main": "index.js",
	"extensions": {
		"uni-cloud-jql": {} // 配置为此云函数开启jql扩展库，值为空对象留作后续追加参数，暂无内容
	},
	"author": ""
}
```

对于确定在云函数/云对象中不需要使用 JQL 扩展库的，请对云函数右键，取消`uni-cloud-jql`扩展库。这样可以减少云函数体积，提高性能。
For those who do not need to use the JQL extension library in cloud functions/cloud objects, right-click the cloud function and cancel the `uni-cloud-jql` extension library. This reduces cloud function volume and improves performance.

## 云函数中使用@use-in-function
## Using @use-in-function in cloud functions

`uniCloud.databaseForJQL`方法，传入客户端信息，就可以得到一个JQL数据库操作对象。
`uniCloud.databaseForJQL` method, pass in the client information, you can get a JQL database operation object.

```js
// 简单的使用示例
// simple usage example
'use strict';
exports.main = async (event, context) => {
	const dbJQL = uniCloud.databaseForJQL({ // 获取JQL database引用，此处需要传入云函数的event和context，必传
		event,
		context 
	})
	const bookQueryRes = await dbJQL.collection('book').where("name=='三国演义'").get() // 直接执行数据库操作
	return {
		bookQueryRes
	}
};
```

## 云对象中使用@use-in-object
## Using @use-in-object in cloud objects

> 新增于 HBuilderX 3.4.10
> Added in HBuilderX 3.4.10

云对象中无法获取`event`和`context`，为方便在云对象中使用jql扩展，自HBuilderX 3.4.10起，`uniCloud.databaseForJQL`方法接收云对象`clientInfo`作为参数
The `event` and `context` cannot be obtained in the cloud object. In order to facilitate the use of jql extensions in the cloud object, since HBuilderX 3.4.10, the `uniCloud.databaseForJQL` method receives the cloud object `clientInfo` as a parameter

**示例**
**Example**

```js
module.exports = {
	addTodo (title, content) {
		const dbJQL = uniCloud.databaseForJQL({ // 获取JQL database引用，此处需要传入云对象的clientInfo
			clientInfo: this.getClientInfo()
		})
	}
}
```


## setUser指定用户身份
## setUser specifies the user identity

上述示例中，jql扩展使用的是客户端的身份，准确的说是客户端的uniIdToken对应的用户作为执行数据库操作的用户。
In the above example, the jql extension uses the client's identity, to be precise, the user corresponding to the client's uniIdToken as the user performing database operations.

如需在云函数/云对象中指定执行其他用户身份，需使用`setUser`方法
To specify another user identity to execute in the cloud function/cloud object, use the `setUser` method

setUser方法的参数是一个对象，可传入uni-id的uid、role、permission，组合生效。
The parameter of the setUser method is an object, which can be passed in the uid, role, and permission of the uni-id, and the combination will take effect.

例：
example:

```js
'use strict';
exports.main = async (event, context) => {
	const dbJQL = uniCloud.databaseForJQL({ // 获取JQL database引用，此处需要传入云函数的event和context
		event,
		context
	})
	dbJQL.setUser({ // 指定后续执行操作的用户信息，此虚拟用户将同时拥有传入的uid、role、permission
		uid: 'user-id', // 建议此处使用真实uid
		role: ['admin'], // 指定当前执行用户的角色为admin。如果只希望指定为admin身份，可以删除uid和permission节点
		permission: []
	})
	const bookQueryRes = await dbJQL.collection('book').where("name=='三国演义'").get() // 直接执行数据库操作
	return {
		bookQueryRes
	}
};
```


## 与clientDB的差异
## Differences with clientDB

虽然都使用 JQL，但云端和客户端还是有一点区别
Although both use JQL, there is still a little difference between the cloud and the client

- clientDB无论如何不可访问password类型字段，不管schema的权限如何，这类数据不传输到客户端。云函数内可以访问password类型字段，但受schema配置的权限约束。
- The password type field is not accessible by clientDB in any way, regardless of the permissions of the schema, such data is not transmitted to the client. The password type field can be accessed within the cloud function, but it is restricted by the permissions configured by the schema.
- clientDB有action云函数的概念，为了弥补客户端操作数据库的不足。云函数没有再使用action的必要了。
- clientDB has the concept of action cloud function, in order to make up for the lack of client operation database. Cloud functions no longer need to use actions.

## 注意事项
## Precautions

- JQL扩展依赖`uni-id`公共模块
- JQL extensions depend on the `uni-id` common module
- 启用了JQL扩展的云函数在本地调试时会自动使用本地schema、action、validateFunction以及uni-id公共模块
- Cloud functions with JQL extension enabled will automatically use local schema, action, validateFunction and uni-id public modules when debugging locally
- 由于此扩展会将`schema`、`action`、`validateFunction`带到模块内，如果你的上述文件较多会大幅增大云函数体积，因此启用此扩展的云函数**冷启动**时间会稍长，建议不要为太多云函数启用此扩展
- Since this extension will bring `schema`, `action`, `validateFunction` into the module, if you have a lot of the above files, it will greatly increase the size of the cloud function, so the cloud function with this extension is enabled **cold start** It will take a little longer, it is recommended not to enable this extension for too many cloud functions
